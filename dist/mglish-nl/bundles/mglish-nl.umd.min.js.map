{"version":3,"sources":["ng://mglish-nl/lib/mglish-nl.service.ts","ng://mglish-nl/lib/mglish-nl.component.ts","ng://mglish-nl/lib/mglish-nl.module.ts"],"names":["MglishNlService","http","this","debug","prototype","request","text","apiKeyGoogle","document","content","type","encodingType","options","headers","Content-Type","params","HttpParams","append","post","JSON","stringify","chunkText","_this","textToChunk","replace","Observable","subscriber","subscribe","result","next","getTextWithChunk","complete","error","chunkTextArray","textArray","i","length","textChunkArray","split","pop","textWithMitre","getTextWithMitre","textWithBreakLine","getTextWithBreakLine","chunkPositionList","handle","Object","keys","newText","previousPosition","fragment","key","hasOwnProperty","tmp","substring","countBegin","countEnd","charAt","repeat","trim","tmpLast","count","part","push","console","log","join","tokens","handleVerb","isConjugateVerb","checkLabel","addChunk","checkCCAndChunk","handleSubj","indexFirst","indexSecond","k","a","b","handleTooLongPart","removeTooShortPart","index","startsWith","verbIndex","verbIndexHead","j","previousKey","stringlength","prepList","commaList","chunkTooLong","closest","goal_1","reduce","prev","curr","Math","abs","indexOf","splice","goal_2","length1","length2","message","includes","label","lenght","checkDependency","headTokenIndex","checkTag","tag","Injectable","args","providedIn","HttpClient","MglishNlComponent","ngOnInit","Component","selector","template","MglishNlModule","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MglishNlService {\n  private debug = true;\n\n  constructor(private http: HttpClient) { }\n\n  private request(text: string, apiKeyGoogle: string) {\n    const params = new HttpParams().append('key', apiKeyGoogle);\n    const url = 'https://cors-anywhere.herokuapp.com/https://language.googleapis.com/v1beta2/documents:analyzeSyntax';\n    const request = {\n      'document': {\n        'content': text,\n        'type': 'PLAIN_TEXT',\n      },\n      'encodingType': 'UTF8',\n    };\n    const options = { headers: { 'Content-Type': 'application/json' }, params: params };\n\n    return this.http.post(url, JSON.stringify(request), options);\n  }\n\n  chunkText(text: string, apiKeyGoogle: string) {\n    const textToChunk = text.replace(/\\â|\\â/g, '\\\"').replace(/\\â/g, '\\'').replace(/\\â/g, '\\-').replace(/\\â¦/g, '...');\n    return new Observable((subscriber) => this.request(textToChunk, apiKeyGoogle).subscribe(\n      (result: any) => {\n        subscriber.next(this.getTextWithChunk(result, textToChunk));\n        subscriber.complete();\n      },\n      error => {\n        subscriber.error(error);\n      })\n    );\n  }\n\n  chunkTextArray(textArray: string[], apiKeyGoogle: string) {\n    let textToChunk = '';\n    for (let i = 0; i < textArray.length; i++) {\n      textToChunk += textArray[i] + 'ã';\n    }\n    textToChunk = textToChunk.replace(/\\â|\\â/g, '\\\"').replace(/\\â/g, '\\'').replace(/\\â/g, '\\-').replace(/\\â¦/g, '...');\n    return new Observable((subscriber) => this.request(textToChunk, apiKeyGoogle).subscribe(\n      (result: any) => {\n        const textWithChunk = this.getTextWithChunk(result, textToChunk.replace(/ã/g, '|||'));\n        const textChunkArray = textWithChunk.split(/\\|{3,}/g);\n        textChunkArray.pop();\n        subscriber.next(textChunkArray);\n        subscriber.complete();\n      },\n      error => {\n        subscriber.error(error);\n      })\n    );\n  }\n\n  textWithMitre(text: string, apiKeyGoogle: string) {\n    const textToChunk = text.replace(/\\â|\\â/g, '\\\"').replace(/\\â/g, '\\'').replace(/\\â/g, '\\-');\n    return new Observable((subscriber) => this.request(textToChunk, apiKeyGoogle).subscribe(\n      (result: any) => {\n        subscriber.next(this.getTextWithMitre(result, textToChunk));\n        subscriber.complete();\n      },\n      error => {\n        subscriber.error(error);\n      })\n    );\n  }\n\n  textWithBreakLine(text: string, apiKeyGoogle: string) {\n    const textToChunk = text.replace(/\\â|\\â/g, '\\\"').replace(/\\â/g, '\\'').replace(/\\â/g, '\\-');\n    return new Observable((subscriber) => this.request(textToChunk, apiKeyGoogle).subscribe(\n      (result: any) => {\n        subscriber.next(this.getTextWithBreakLine(result, textToChunk));\n        subscriber.complete();\n      },\n      error => {\n        subscriber.error(error);\n      })\n    );\n  }\n\n  chunkPositionList(text: string, apiKeyGoogle: string) {\n    const textToChunk = text.replace(/\\â|\\â/g, '\\\"').replace(/\\â/g, '\\'').replace(/\\â/g, '\\-');\n    return new Observable((subscriber) => this.request(textToChunk, apiKeyGoogle).subscribe(\n      (result: any) => {\n        subscriber.next(this.handle(result, textToChunk));\n        subscriber.complete();\n      },\n      error => {\n        subscriber.error(error);\n      })\n    );\n  }\n\n\n  private getTextWithMitre(result: { sentences: [], tokens: [], language: string }, text: string) {\n    const chunkPositionList = this.handle(result, text);\n    if (Object.keys(chunkPositionList).length === 0) {\n      return 'ã' + text + 'ã';\n    } else {\n      let newText = '';\n      let previousPosition = 0;\n      let fragment = '';\n      for (const key in chunkPositionList) {\n        if (chunkPositionList.hasOwnProperty(key)) {\n          const tmp = text.substring(chunkPositionList[previousPosition], chunkPositionList[key]);\n          let countBegin = 0;\n          let countEnd = tmp.length - 1;\n          while (countBegin < tmp.length && tmp.charAt(countBegin) === '\\n') {\n            countBegin++;\n          }\n          while (countEnd > 0 && tmp.charAt(countEnd) === '\\n') {\n            countEnd--;\n          }\n          countEnd = tmp.length - 1 - countEnd;\n\n          fragment = '\\n'.repeat(countBegin);\n          fragment += 'ã';\n          fragment += tmp.trim();\n          fragment += 'ã' + '\\n'.repeat(countEnd);\n          if (countEnd === 0) {\n            fragment += 'ã';\n          }\n\n          newText = newText + fragment;\n          previousPosition = +key;\n        }\n      }\n      const tmpLast = text.substring(chunkPositionList[previousPosition], text.length);\n      let count = 0;\n      while (count < tmpLast.length && tmpLast.charAt(count) === '\\n') {\n        count++;\n      }\n\n      fragment = count === 0 ? '' : '\\n'.repeat(count);\n      fragment += 'ã' + tmpLast.trim() + 'ã';\n      newText = newText + fragment;\n      return newText;\n    }\n  }\n\n  private getTextWithBreakLine(result: { sentences: [], tokens: [], language: string }, text: string) {\n    const chunkPositionList = this.handle(result, text);\n    if (Object.keys(chunkPositionList).length === 0) {\n      return text;\n    } else {\n      const part = [];\n      let previousPosition = 0;\n      let fragment: string;\n      for (const key in chunkPositionList) {\n        if (chunkPositionList.hasOwnProperty(key)) {\n          fragment = text.substring(chunkPositionList[previousPosition], chunkPositionList[key]);\n          part.push(fragment);\n          previousPosition = +key;\n        }\n      }\n      fragment = text.substring(chunkPositionList[previousPosition], text.length);\n      part.push(fragment);\n      console.log(part);\n      return part.join('\\n');\n    }\n  }\n\n  private getTextWithChunk(result: { sentences: [], tokens: [], language: string }, text: string) {\n    const chunkPositionList = this.handle(result, text);\n    if (Object.keys(chunkPositionList).length === 0) {\n      return text;\n    } else {\n      const part = [];\n      let previousPosition = 0;\n      let fragment: string;\n      for (const key in chunkPositionList) {\n        if (chunkPositionList.hasOwnProperty(key)) {\n          fragment = text.substring(chunkPositionList[previousPosition], chunkPositionList[key]);\n          part.push(fragment);\n          previousPosition = +key;\n        }\n      }\n      fragment = text.substring(chunkPositionList[previousPosition], text.length);\n      part.push(fragment);\n      console.log(part);\n      return part.join('|');\n    }\n  }\n\n  handle(result: { sentences: [], tokens: [], language: string }, text: string) {\n    const chunkPositionList: Record<number, number> = {};\n    const tokens = result.tokens;\n\n    for (let i = 0; i < tokens.length; i++) {\n      switch (tokens[i]['dependencyEdge']['label']) {\n        case 'ROOT':\n          this.handleVerb(tokens, i, chunkPositionList);\n          break;\n        case 'CCOMP':\n          this.handleVerb(tokens, i, chunkPositionList);\n          break;\n        case 'RCMOD':\n          this.handleVerb(tokens, i, chunkPositionList);\n          break;\n        case 'CONJ':\n          if (this.isConjugateVerb(i, tokens) || tokens[tokens[i]['dependencyEdge']['headTokenIndex']]['dependencyEdge']['label'] === 'ROOT'\n            || tokens[tokens[i]['dependencyEdge']['headTokenIndex']]['dependencyEdge']['label'] === 'CCOMP'\n            || tokens[tokens[i]['dependencyEdge']['headTokenIndex']]['dependencyEdge']['label'] === 'RCMOD'\n            || tokens[tokens[i]['dependencyEdge']['headTokenIndex']]['dependencyEdge']['label'] === 'ADVCL'\n            || tokens[tokens[i]['dependencyEdge']['headTokenIndex']]['dependencyEdge']['label'] === 'PARATAXIS') {\n            this.handleVerb(tokens, i, chunkPositionList);\n          }\n          break;\n        case 'PARATAXIS':\n          if (this.isConjugateVerb(i, tokens)) {\n            this.handleVerb(tokens, i, chunkPositionList);\n          }\n          break;\n        case 'ADVCL':\n          if (tokens[i]['partOfSpeech']['tag'] === 'VERB') {\n            this.handleVerb(tokens, i, chunkPositionList);\n          }\n          break;\n        // acomp example : being able, cut after acomp if exist\n        case 'PCOMP':\n          if (i > 1 && i < tokens.length - 1) {\n            if (i < tokens.length - 2 && this.checkLabel(['ACOMP'], i + 1, tokens)) {\n              this.addChunk(chunkPositionList, i + 2, tokens, 'pcomp + acomp:' + i);\n            } else {\n              this.addChunk(chunkPositionList, i + 1, tokens, 'pcomp:' + i);\n            }\n          }\n          break;\n        case 'PREP':\n          // check if previous word is related, chunk if not\n          // special rules: break if previous word = aux\n          // chunk before previous words if previous word = mwe\n          if (i > 2 && (this.checkLabel(['AUX', 'AUXPASS'], i - 1, tokens)\n            && tokens[i - 1]['dependencyEdge']['headTokenIndex'] > i)) {\n            break;\n          }\n          if (i > 2 && ((this.checkLabel(['MWE'], i - 1, tokens) && tokens[i - 1]['dependencyEdge']['headTokenIndex'] === i))) {\n            this.checkCCAndChunk(chunkPositionList, i - 1, tokens, 'prep mwe:' + i);\n            break;\n          }\n          if (i > 0 && tokens[i]['dependencyEdge']['headTokenIndex'] !== i - 1 &&\n            tokens[i - 1]['dependencyEdge']['headTokenIndex'] !== i) {\n            if (i > 1 && this.isConjugateVerb(i - 2, tokens)) {\n              break;\n            }\n            this.checkCCAndChunk(chunkPositionList, i, tokens, 'prep:' + i);\n          }\n          break;\n        case 'MARK':\n          if (i > 1) {\n            this.addChunk(chunkPositionList, i, tokens, 'mark: ' + i);\n          }\n          break;\n        case 'NSUBJ':\n          this.handleSubj(tokens, i, chunkPositionList);\n          break;\n        case 'NSUBJPASS':\n          this.handleSubj(tokens, i, chunkPositionList);\n          break;\n        case 'P':\n          if (tokens[i]['text']['content'] === '.' || tokens[i]['text']['content'] === '!' || tokens[i]['text']['content'] === '?') {\n            if (i < tokens.length - 1) {\n              console.log(tokens[i + 1]['text']['content'] === '-');\n            }\n            if (i < tokens.length - 1\n              && !(tokens[i + 1]['text']['content'] === '.'\n                || tokens[i + 1]['text']['content'] === '!'\n                || tokens[i + 1]['text']['content'] === '?'\n                || tokens[i + 1]['text']['content'] === '-')) {\n              this.addChunk(chunkPositionList, i + 1, tokens, 'punctuation: ' + i);\n            }\n          }\n          break;\n        case 'CC':\n          // chunk if words behind and after too long\n          const indexFirst = tokens[i]['dependencyEdge']['headTokenIndex'];\n          if (i < indexFirst) {\n            break;\n          }\n          let indexSecond: number;\n          for (let k = i + 1; k < tokens.length; k++) {\n            if (this.checkLabel(['CONJ'], k, tokens) && tokens[k]['dependencyEdge']['headTokenIndex'] === indexFirst) {\n              indexSecond = k;\n              break;\n            }\n          }\n          if (typeof indexSecond === 'undefined') {\n            break;\n          }\n          let count = indexSecond - indexFirst;\n          let a = indexFirst - 1;\n          while (a > 0 && tokens[a]['dependencyEdge']['headTokenIndex'] === indexFirst) {\n            count++;\n            a--;\n          }\n          let b = indexSecond + 1;\n          while (b > tokens.length - 1 && tokens[b]['dependencyEdge']['headTokenIndex'] === indexSecond) {\n            count++;\n            b++;\n          }\n          if (count > 2) {\n            this.addChunk(chunkPositionList, i, tokens, 'cc :' + i);\n          }\n          break;\n        case 'AUX':\n          // chunk if following is verb, example 'to do'\n          if (i > 0 && i < tokens.length - 2 && tokens[i]['partOfSpeech']['tag'] === 'PRT'\n            && tokens[i + 1]['partOfSpeech']['tag'] === 'VERB') {\n            this.addChunk(chunkPositionList, i, tokens, 'aux :' + i);\n          }\n          break;\n        case 'VMOD':\n          // chunk before vmod if previous word not verb\n          if (i > 2 && tokens[i - 1]['partOfSpeech']['tag'] !== 'PRT') {\n            this.addChunk(chunkPositionList, i, tokens, 'vmod :' + i);\n          }\n          break;\n        case 'ADVMOD':\n          // chunk before vmod if previous word not verb\n          if (i > 2 && (tokens[i]['text']['content'] === 'as'\n            || tokens[i]['text']['content'] === 'when' || tokens[i]['text']['content'] === 'where')) {\n            this.addChunk(chunkPositionList, i, tokens, 'advmod :' + i);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n\n    this.handleTooLongPart(tokens, chunkPositionList);\n    this.removeTooShortPart(tokens, chunkPositionList);\n\n    return chunkPositionList;\n  }\n\n  // chunk after verb, keep following prt if exists\n  private handleVerb(tokens: any, index: number, chunkPositionList: Record<number, number>) {\n    if (index !== tokens.length - 1 &&\n      ((this.checkLabel(['PRT', 'XCOMP'], index + 1, tokens) && tokens[index + 1]['dependencyEdge']['headTokenIndex'] === index)\n        || this.checkLabel(['ACOMP'], index + 1, tokens))\n    ) {\n      if (index + 1 < tokens.length - 1) {\n        this.addChunk(chunkPositionList, index + 2, tokens, 'verb :' + index);\n      }\n    } else {\n      if (index !== tokens.length - 1) {\n        this.addChunk(chunkPositionList, index + 1, tokens, 'verb :' + index);\n      }\n    }\n  }\n\n  // check length of subject if too long, chunk subj / verb\n  private handleSubj(tokens: any, index: number, chunkPositionList: Record<number, number>) {\n    if (!(index < tokens.length - 1 && ((<string>tokens[index + 1]['text']['content']).startsWith('\\'')\n      || (<string>tokens[index + 1]['text']['content']).startsWith('\\â')))) {\n      const verbIndex = tokens[index]['dependencyEdge']['headTokenIndex'];\n      const verbIndexHead = tokens[verbIndex]['dependencyEdge']['headTokenIndex'];\n\n      let k = index - 1;\n      while (k >= 0 && (tokens[k]['dependencyEdge']['headTokenIndex'] === index\n        || tokens[k]['dependencyEdge']['headTokenIndex'] === k + 1\n        || tokens[k]['dependencyEdge']['headTokenIndex'] === verbIndex\n        || (tokens[k]['dependencyEdge']['headTokenIndex'] === verbIndexHead && !this.checkLabel(['P'], k, tokens))\n        || this.checkLabel(['ADVMOD', 'AMOD', 'PS'], index - 1, tokens))) {\n        k--;\n      }\n      if (k > 0) {\n        this.checkCCAndChunk(chunkPositionList, k + 1, tokens, 'nsubj: ' + index);\n      }\n\n      if (verbIndex < index) {\n        if (index !== tokens.length - 1 &&\n          ((this.checkLabel(['PRT'], verbIndex + 1, tokens) && tokens[verbIndex + 1]['dependencyEdge']['headTokenIndex'] === verbIndex)\n            || this.checkLabel(['ACOMP'], verbIndex + 1, tokens))\n        ) {\n          if (verbIndex + 1 < tokens.length - 1) {\n            delete chunkPositionList[verbIndex + 2];\n          }\n        } else {\n          if (verbIndex !== tokens.length - 1) {\n            delete chunkPositionList[verbIndex + 1];\n          }\n        }\n      } else {\n        let count = verbIndex - index + 1;\n\n        if (verbIndex < tokens.length - 1 &&\n          this.checkLabel(['PRT'], verbIndex + 1, tokens) && tokens[verbIndex + 1]['dependencyEdge']['headTokenIndex'] === index) {\n          count++;\n        }\n        let j = index - 1;\n        while (j >= 0 && tokens[j]['dependencyEdge']['headTokenIndex'] <= verbIndex\n          && (tokens[j]['dependencyEdge']['headTokenIndex'] >= j)) {\n          count++;\n          j--;\n        }\n\n        if (count > 5) {\n          if (verbIndex > 2 && (this.checkLabel(['AUX', 'AUXPASS'], verbIndex - 2, tokens))) {\n            this.addChunk(chunkPositionList, verbIndex - 2, tokens, 'subj + aux 2:' + index);\n          } else {\n            if (verbIndex > 1 && (this.checkLabel(['AUX', 'AUXPASS'], verbIndex - 1, tokens))) {\n              this.addChunk(chunkPositionList, verbIndex - 1, tokens, 'subj + aux 1:' + index);\n            } else {\n              if (verbIndex > 1) {\n                this.addChunk(chunkPositionList, verbIndex, tokens, 'subj:' + index);\n              }\n            }\n          }\n        }\n        console.log('count ' + index + ': ' + count);\n      }\n    }\n  }\n\n  private handleTooLongPart(tokens: any, chunkPositionList: Record<number, number>) {\n    const keys = Object.keys(chunkPositionList);\n    let previousKey = 0;\n    let key, length: number;\n    for (let index = 0; index < keys.length; index++) {\n      key = keys[index];\n      if (chunkPositionList.hasOwnProperty(key)) {\n        length = +key - previousKey;\n        if (length >= 6) {\n          const stringlength = +tokens[key]['text']['beginOffset'] - +tokens[previousKey]['text']['beginOffset'];\n          console.log(stringlength);\n          if (stringlength >= 35) {\n            const prepList = [];\n            const commaList = [];\n            for (let i = previousKey + 2; i < +key; i++) {\n              switch (tokens[i]['dependencyEdge']['label']) {\n                case 'PREP':\n                  // if (i > 1 && tokens[i - 1]['partOfSpeech']['tag'] === 'VERB') {\n                  //   break;\n                  // }\n                  if (i > 2 && (this.checkLabel(['AUX', 'AUXPASS'], i - 1, tokens))\n                    && tokens[i - 1]['dependencyEdge']['headTokenIndex'] > i) {\n                    break;\n                  }\n                  // if (tokens[i]['text']['content'] === 'of') {\n                  //   prepList.push(i + 1);\n                  // } else {\n                  prepList.push(i);\n                  // }\n                  break;\n                case 'P':\n                  if (tokens[i]['text']['content'] === ',' || tokens[i]['text']['content'] === ';') {\n                    commaList.push(i);\n                  }\n                  break;\n                default:\n                  break;\n              }\n            }\n            this.chunkTooLong(tokens, chunkPositionList, prepList, commaList, +key, previousKey);\n          } else {\n            console.log('not too long 1: ' + stringlength);\n          }\n        }\n        previousKey = +key;\n      }\n    }\n    key = tokens.length - 1;\n    length = +key - previousKey + 1;\n    if (length >= 6) {\n      const stringlength = +tokens[key]['text']['beginOffset'] - +tokens[previousKey]['text']['beginOffset'];\n      if (stringlength >= 35) {\n        console.log(previousKey + ' to ' + key + ' too long: ' + stringlength);\n        const prepList = [];\n        const commaList = [];\n        for (let i = previousKey + 2; i < +key; i++) {\n          switch (tokens[i]['dependencyEdge']['label']) {\n            case 'PREP':\n              prepList.push(i);\n              break;\n            case 'P':\n              if (tokens[i]['text']['content'] === ',' || tokens[i]['text']['content'] === ';') {\n                commaList.push(i);\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        this.chunkTooLong(tokens, chunkPositionList, prepList, commaList, +key, previousKey);\n      } else {\n        console.log('not too long 2: ' + stringlength);\n      }\n    }\n    console.log(chunkPositionList);\n  }\n\n  private chunkTooLong(tokens: any, chunkPositionList: Record<number, number>, prepList: number[],\n    commaList: number[], key: number, previousKey: number) {\n    console.log(previousKey + ' to ' + key + ' too long: ');\n\n    let closest = null;\n    if (prepList.length !== 0) {\n      console.log(prepList);\n      const goal = (key + previousKey) / 2;\n      console.log('goal: ' + goal);\n      closest = prepList.reduce(function (prev, curr) {\n        return (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev);\n      });\n      if (closest < key && closest > previousKey) {\n        this.addChunk(chunkPositionList, closest, tokens, 'too long part prep: ' + closest);\n\n        const index = prepList.indexOf(closest);\n        prepList.splice(index, 1);\n      } else {\n        closest = null;\n      }\n    } else {\n      if (commaList.length !== 0) {\n        console.log(commaList);\n        const goal = (+key + previousKey) / 2;\n        console.log('goal: ' + goal);\n        closest = commaList.reduce(function (prev, curr) {\n          return (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev);\n        });\n        console.log('closest: ' + closest);\n\n        if (closest < key && closest > previousKey) {\n          this.addChunk(chunkPositionList, closest + 1, tokens, 'too long part comma:' + closest);\n\n          const index = commaList.indexOf(closest);\n          commaList.splice(index, 1);\n        } else {\n          closest = null;\n        }\n      }\n    }\n    if (closest !== null) {\n      const length1 = +tokens[closest]['text']['beginOffset'] - +tokens[previousKey]['text']['beginOffset'];\n      const length2 = +tokens[key]['text']['beginOffset'] - +tokens[closest]['text']['beginOffset'];\n      console.log('1: ' + length1 + ' 2: ' + length2);\n      if (length1 > 30) {\n        this.chunkTooLong(tokens, chunkPositionList, prepList, commaList, closest, previousKey);\n      }\n      if (length2 > 30) {\n        this.chunkTooLong(tokens, chunkPositionList, prepList, commaList, key, closest);\n      }\n    }\n  }\n\n  private removeTooShortPart(tokens: any, chunkPositionList: Record<number, number>) {\n    const keys = Object.keys(chunkPositionList);\n    let previousKey = 0;\n    let key, length;\n    for (let index = 0; index < keys.length; index++) {\n      key = keys[index];\n      if (chunkPositionList.hasOwnProperty(key)) {\n        length = +key - previousKey;\n        if (length === 1) {\n          if ((tokens[previousKey]['partOfSpeech']['tag'] === 'VERB' && !this.checkLabel(['VMOD'], previousKey, tokens) ||\n            (previousKey > 0 && this.checkLabel(['P'], previousKey - 1, tokens)))) {\n            delete chunkPositionList[key];\n          } else {\n            if (tokens[previousKey]['dependencyEdge']['headTokenIndex'] < previousKey\n              || (!this.checkLabel(['ADVMOD'], previousKey, tokens) && this.isConjugateVerb(previousKey - 1, tokens))) {\n              delete chunkPositionList[previousKey];\n              console.log('previous');\n            } else {\n              delete chunkPositionList[key];\n              console.log('next');\n            }\n          }\n          if (this.debug) {\n            console.log('remove chunk too short: ' + key);\n          }\n        }\n        if (length === 2) {\n          if (previousKey !== 0 && this.checkLabel(['P'], +key - 1, tokens)) {\n            // if (tokens[previousKey]['partOfSpeech']['tag'] === 'VERB') {\n            //   delete chunkPositionList[key];\n            // } else {\n            //   if (tokens[previousKey]['dependencyEdge']['headTokenIndex'] < previousKey) {\n            delete chunkPositionList[previousKey];\n            // } else {\n            //   delete chunkPositionList[key];\n            // }\n            // }\n            if (this.debug) {\n              console.log('remove chunk too short: ' + key);\n            }\n          }\n        }\n        previousKey = +key;\n      }\n    }\n    key = tokens.length - 1;\n    length = +key - previousKey + 1;\n    if (length === 1) {\n      delete chunkPositionList[previousKey];\n      if (this.debug) {\n        console.log('remove chunk too short: ' + key);\n      }\n    }\n    if (length === 2) {\n      if (previousKey !== 0 && this.checkLabel(['P'], +previousKey + 1, tokens)) {\n        delete chunkPositionList[previousKey];\n        if (this.debug) {\n          console.log('remove chunk too short: ' + key);\n        }\n      }\n    }\n    console.log(chunkPositionList);\n  }\n\n  private addChunk(chunkPositionList: Record<number, number>, index: number, tokens: any, message: string) {\n    if (index > 0 && index < tokens.length - 1) {\n      if (this.debug) {\n        console.log('add chunk ' + index + ' :' + message);\n      }\n      if (index > 1 && this.checkLabel(['P'], index - 1, tokens) &&\n        (tokens[index - 1]['text']['content'] === '(' ||\n          ((tokens[index - 1]['text']['content'] === '\"') && tokens[index - 1]['dependencyEdge']['headTokenIndex'] !== index))) {\n        chunkPositionList[index - 1] = tokens[index - 2]['text']['beginOffset'] + tokens[index - 2]['text']['content'].length;\n      } else {\n        let j = index;\n        while (j < tokens.length && this.checkLabel(['P'], j, tokens)) {\n          if (j < tokens.length - 1 && (tokens[j]['text']['content'] === '-'\n            || tokens[j]['text']['content'] === '(' || tokens[j]['text']['content'] === '\"')) {\n            break;\n          }\n          j++;\n        }\n        if (j < tokens.length - 2 && j > 0) {\n          if ((<string>tokens[j - 1]['text']['content']).includes('ã')) {\n            chunkPositionList[j] = tokens[j - 1]['text']['beginOffset'] + tokens[j - 1]['text']['content'].split('ã')[0].length;\n          } else {\n            chunkPositionList[j] = tokens[j - 1]['text']['beginOffset'] + tokens[j - 1]['text']['content'].length;\n          }\n        }\n      }\n      // if (this.checkLabel(['P'], index, tokens)) {\n      //   if (index < tokens.length - 2) {\n      //     chunkPositionList[index + 1] = tokens[index + 1]['text']['beginOffset'] - 1;\n      //   }\n      // } else {\n      //   chunkPositionList[index] = tokens[index]['text']['beginOffset'] - 1;\n      // }\n    }\n  }\n\n  private checkCCAndChunk(chunkPositionList: Record<number, number>, index: number, tokens: any, message: string) {\n    if (this.checkLabel(['CC'], index - 1, tokens)) {\n      this.addChunk(chunkPositionList, index - 1, tokens, message);\n    } else {\n      this.addChunk(chunkPositionList, index, tokens, message);\n    }\n  }\n\n  private checkLabel(label: string[], index: number, tokens: any) {\n    if (index < 0 || index >= tokens.lenght) {\n      return false;\n    }\n    let b = false;\n    for (let i = 0; i < label.length; i++) {\n      if (tokens[index]['dependencyEdge']['label'] === label[i]) {\n        b = true;\n        break;\n      }\n    }\n    return b;\n  }\n\n  private checkDependency(headTokenIndex: string, index: number, tokens: any) {\n    return tokens[index]['dependencyEdge']['headTokenIndex'] === headTokenIndex;\n  }\n\n  private checkTag(tag: string, index: number, tokens: any) {\n    return tokens[index]['partOfSpeech']['tag'] === tag;\n  }\n\n  private isConjugateVerb(index: number, tokens: any) {\n    if (index < 0 || index >= tokens.lenght) {\n      return false;\n    }\n    return tokens[index]['partOfSpeech']['tag'] === 'VERB' && (tokens[index]['partOfSpeech']['tense'] !== 'TENSE_UNKNOWN'\n      || tokens[index]['lemma'] !== tokens[index]['text']['content']);\n  }\n}\n","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'lib-mglish-nl',\n  template: `\n    <p>\n      mglish-nl works!\n    </p>\n  `,\n  styles: []\n})\nexport class MglishNlComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { MglishNlComponent } from './mglish-nl.component';\n\n@NgModule({\n  declarations: [MglishNlComponent],\n  imports: [\n  ],\n  exports: [MglishNlComponent]\n})\nexport class MglishNlModule { }\n"]}